# 开发中遇到的问题

## 无法避免的数据类型不一致

> 需要在某一层强制类型转换

userID 的 int64 / uint64 可以在“源头”统一，但必须选对“源头”

✅ 推荐：数据库 / 领域模型统一用 uint64
❌ 不推荐：HTTP / JWT 层强行用 uint64

### 为什么“ID 只能为正”，但 JWT / HTTP 仍常用 int64？

这是现实工程里的一个反直觉点。

事实：

MySQL BIGINT UNSIGNED → 天然是 uint64

但：

- JWT Claims
- Gin Context
- JSON number
- JS number

👉 都更安全地用 int64

原因不是“业务”，而是生态兼容性。

### 正确的“源头统一点”在哪里？

❌ 不该统一在这里

|层	|原因|
|---|---|
|JWT Claims	|JSON / 前端生态不友好|
|Handler	|不该做类型假设|
|Context	|类型不稳定|

✅ 正确统一点：Domain / Service 层

你的系统应该形成这个规则：

```txt
外部世界（HTTP/JWT）: int64
内部领域模型（Order/User）: uint64
```

在 Service 层做一次、且只做一次转换：
```go
uid := uint64(userID) // Service 边界
```

如果想从源头就统一，唯一合理的地方是：

数据库 schema
```sql
user_id BIGINT UNSIGNED NOT NULL
```

以及：
```go
type User struct {
	ID uint64
}
```

但不要试图强迫 JWT / JSON 也用 uint64。

### 工程级总结

“ID 是正数”是业务事实
“int64 / uint64”是技术选择

把转换集中在 Service 层边界，这是长期最稳的做法。

##
