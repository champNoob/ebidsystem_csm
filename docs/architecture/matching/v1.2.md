# 撮合引擎-1.2

## 主要修改

### 1. 在服务层调用 `submit` 方法

internal\service\order_service.go 文件中的 CreateOrder 方法：

```go
orderID, err := s.repo.Create(ctx, order)
if err != nil {
	return err
}

// 向撮合引擎递交订单
s.matcher.Submit(&matching.Order{
	ID:       orderID,
	UserID:   userID,
	Symbol:   order.Symbol,
	Side:     matching.Side(order.Side),
	Price:    *order.Price,
	Quantity: order.Quantity,
})
```

### 2. 将装配工作由 `router.go`转到 `main.go` 中

`main.go` 只应负责 全部依赖装配，`router.go` 只负责 注册路由

#### 原 `router.go` 中的装配工作：

```go
func SetupRouter() *gin.Engine {
	r := gin.New()
	r.Use(gin.Recovery())

	// === 装配依赖 ===
	userRepo := mysql.NewUserRepo(database.MySQL)
	userService := service.NewUserService(userRepo)
	userHandler := handler.NewUserHandler(userService)

	orderRepo := mysql.NewOrderRepo(database.MySQL)
	orderService := service.NewOrderService(orderRepo)
	orderHandler := handler.NewOrderHandler(orderService)

	// === 注册路由 ===
	r.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"status": "ok",
		})
	})
	...
	// === 需要登录 ===
	...
	// === 管理员接口 ===
	...
	return r
}
```

问题在于：

- Router 不应该知道 Repo / DB
- Router 不应该 new Service
- Router 不应该决定“用 MySQL 还是 Redis”

否则后果是：

- 无法测试
- 无法替换实现
- 撮合引擎无法注入

最终 main.go 失去控制权

#### 改进后的 `main.go`

```go
func main() {
	// 1. 加载配置：
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("load config failed: %v", err)
	}

	// 2. 初始化数据库：
	if err := database.InitMySQL(cfg.MySQL); err != nil {
		log.Fatalf("init mysql failed: %v", err)
	}
	if err := database.InitRedis(cfg.Redis); err != nil {
		log.Fatalf("init redis failed: %v", err)
	}

	// 3. 初始化撮合引擎（matching）
	engine := matching.NewEngine()
	engine.Start()

	// 4. 初始化仓储层（repository）
	userRepo := mysql.NewUserRepo(database.MySQL)
	orderRepo := mysql.NewOrderRepo(database.MySQL) //"cfg.MySQL"?

	// 5. 初始化服务层（service）
	orderService := service.NewOrderService(orderRepo, engine)
	userService := service.NewUserService(userRepo)

	// 6. 初始化处理器（Handler）
	userHandler := handler.NewUserHandler(userService)
	orderHandler := handler.NewOrderHandler(orderService)

	// 7. Router（Http服务，只接收 handler）
	r := route.SetupRouter(
		userHandler,
		orderHandler,
	)
	if err := r.Run(cfg.Server.Addr); err != nil {
		log.Fatalf("server start failed: %v", err)
	}
}
```

样做的直接好处（非常现实）

| 好处 | 说明 |
|------|------|
| 撮合引擎只创建一次|不会重复|
| 所有 Service 共享 matcher|订单流统一|
| router 纯净|无业务污染|
| 易测试|可注入 mock|
| 未来可上 Wire|完美适配|
