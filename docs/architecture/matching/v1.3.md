# 撮合引擎-1.3

## 部分成交支持

### 1. 引入 Remaining 概念（撮合引擎内部）

**改动前**
- 使用 order.Quantity 表示“还可成交的数量”

**改动后**
- 初始：
  Remaining = Quantity
- 每次撮合：
  Remaining -= matchedQty

Remaining 是**撮合引擎内部状态**，不直接依赖数据库字段。


### 2. 撮合算法改为“最小剩余量成交”

```go
matchedQty = min(buy.Remaining, sell.Remaining)
```

确保不会出现“超卖 / 超买”，为多次撮合奠定基础

### 3. 订单簿移除逻辑调整
```go
if buy.Remaining == 0 {
    remove buy order
}
if sell.Remaining == 0 {
    remove sell order
}
```
关键点：

同一订单可能在多轮 Match 中存在

只有 Remaining 为 0 才真正“出簿”

### 4. 撮合事件（MatchEvent）改为“增量事件”
每个事件只代表本次成交量：

```go
type MatchEvent struct {
    BuyOrderID
    SellOrderID
    Price
    Quantity   // 本次成交量
}
而不是“订单最终状态”。

### 5. 数据库侧引入 filled_quantity
```sql
filled_quantity BIGINT NOT NULL DEFAULT 0
```
并通过 累加更新：

```sql
filled_quantity = filled_quantity + ?
```
避免：

覆盖式更新

并发下的成交丢失

### 6. 状态推进规则收敛到数据库层
```sql
CASE
  WHEN filled_quantity + ? >= quantity THEN 'filled'
  ELSE 'partial'
END
```
状态语义明确：

pending：未成交

partial：已部分成交，仍可成交

filled：已完全成交，不可再动

## 撤单支持

撤单时需要考虑订单的成交状态：

- pending：可以直接撤单，无需处理成交数据
- partial：需要将已成交部分从 filled_quantity 中扣除，并更新订单状态
- filled：不能撤单

撤单逻辑应该在数据库层实现，确保数据一致性。

### 优化订单校验逻辑

在 `func (s *OrderService) CancelOrder` 函数中，应该**先做权限校验，再做状态校验**，确保不向无权限用户泄露业务状态信息

### 通用订单状态转换函数的隐患

如果在撤单 `repo` 层实现通用的状态转换函数（`UpdateStatus`），可能会因缺少业务约束，导致订单状态非法变更

> 正确做法：对撤单等功能调用**专用 SQL + 状态条件**的函数

`UpdateStatus` 可以保留，但**禁止**用于撤单

### 接口测试

#### 1. 撤不存在的订单 ×

```
{
    "error": "order is not cancellable"
}
```

#### 2. 撤已等待中的订单 ✓

```json
{
    "message": "order canceled"
}
```

成功撤回后，另一方拍单（同一证券代码、合法）后应无法使二者的订单撮合

#### 3. 撤部分成交的订单 ✓

```
{
    "message": "order canceled"
}
```

#### 4. 撤已成交的订单 ×

```
{
    "error": "order is not cancellable"
}
```

#### 5. 撤已撤单的订单 ×

```json
{
    "error": "order is not cancellable"
}
```

#### 6. 撤不属于自己的订单（横向越权） ×

```json
{
    "error": "invalid token"
}
```