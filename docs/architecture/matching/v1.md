# 第一版撮合引擎

## 〇、 目录结构

```txt
internal/
├── matching/              # 撮合引擎（核心）
│   ├── engine.go          # 撮合引擎入口
│   ├── order_book.go      # 订单簿
│   ├── matcher.go         # 撮合逻辑
│   ├── event.go           # 撮合结果事件
│   └── types.go           # 核心类型
```

## 一、全链路总览图

```txt
Client (Postman / 前端)
    |
    | HTTP POST /api/orders
    v
Gin Router
    |
    v
OrderHandler.CreateOrder
    |
    v
OrderService.CreateOrder
    |
    | 1. 参数校验
    | 2. 权限校验
    | 3. 写 orders 表（status=pending）
    |
    v
MatchingEngine.Submit(order)
    |
    v
[ goroutine + channel ]
    |
    v
OrderBook (symbol级)
    |
    v
Matcher
    |
    v
MatchEvent(s)
    |
    v
Service / Repository
    |
    | 更新订单状态
    | 写成交记录（trade）
    |
    v
返回 HTTP 响应（下单成功）
```

注意一个核心点：

> **HTTP 请求在“提交订单”后就返回了
> 撮合是异步发生的**

这是**真实交易系统的标准做法**。

## 二、从“买单”开始，逐模块走一遍

### Step 1：客户端发起买单

#### 请求

```http
POST /api/orders
Authorization: Bearer <JWT>

{
  "symbol": "BTC-USDT",
  "side": "buy",
  "price": 50000,
  "quantity": 1
}
```

### Step 2：Gin Router

```go
authGroup.POST("/orders", orderHandler.CreateOrder)
```

作用：

* 路由匹配
* JWT 中间件解析 token
* 把 `userID / role` 放入 gin.Context

### Step 3：OrderHandler.CreateOrder（接口层）

职责（非常重要）：

> **只做“协议层”的事**

* JSON → DTO
* 从 Context 取 userID
* 不做业务判断

典型流程：

```go
userID := c.GetInt64("userID")

req := CreateOrderRequest{}
c.ShouldBindJSON(&req)

err := service.CreateOrder(ctx, userID, req)
```

**Handler 不知道撮合怎么做**

### Step 4：OrderService.CreateOrder（业务层）

这是**第一个关键点**

#### 这里发生的事情（顺序固定）：

- 1. 业务校验

  - side 是否合法
  - price > 0
  - quantity > 0
  - 用户是否有权限下单（role）

- 2. 构造数据库 Order Model

```go
order := &model.Order{
	UserID:   userID,
	Symbol:   req.Symbol,
	Side:     req.Side,
	Price:    &req.Price,
	Quantity: req.Quantity,
	Status:   model.OrderStatusPending,
}
```

- 3. 写数据库（非常关键）

```go
repo.CreateOrder(ctx, order)
```

此时数据库状态：

| id  | user_id | side | price | quantity | status  |
| --- | ------- | ---- | ----- | -------- | ------- |
| 101 | 1       | buy  | 50000 | 1        | pending |

> **为什么先写库？**
>
> * 防止进程崩溃丢单
> * DB 是最终一致性源

### Step 5：把订单投递给撮合引擎（异步）

```go
engine.Submit(&matching.Order{
	ID:       order.ID,
	UserID:   order.UserID,
	Symbol:   order.Symbol,
	Side:     matching.Buy,
	Price:    *order.Price,
	Quantity: order.Quantity,
})
```

此刻：

* HTTP 请求 **即将返回**
* 撮合在后台 goroutine 中进行

### Step 6：HTTP 返回（重要设计点）

```json
{
  "message": "order created",
  "order_id": 101
}
```

**注意**：

* ❌ 不返回是否成交
* ❌ 不阻塞等待撮合
* ✅ 极快响应

这是**高并发系统的核心设计**。

## 三、撮合引擎内部发生了什么？

### Step 7：MatchingEngine goroutine 接收订单

```go
order := <-orderCh
```

特性：

* 单 goroutine
* 串行处理
* 无锁

### Step 8：定位 OrderBook（symbol 级）

```go
ob := books["BTC-USDT"]
```

如果不存在就新建。

**一个 symbol = 一个“逻辑撮合队列”**

### Step 9：订单进入订单簿

```go
ob.AddOrder(order)
```

此时 OrderBook 里可能是：

```
Buy Orders:
  [ buy 50000 x1 ]

Sell Orders:
  [ sell 49500 x1 ]
```

### Step 10：Matcher 开始撮合

```go
events := ob.Match()
```

撮合条件：

```go
buy.Price >= sell.Price
```

成立 → 成交。

### Step 11：生成 MatchEvent（领域事件）

```go
MatchEvent{
	BuyOrderID:  101,
	SellOrderID: 88,
	Price:       49500,
	Quantity:    1,
}
```

注意：

> **这是内存事件，还没落库**

## 四、撮合结果如何“安全入库”

### Step 12：处理 MatchEvent（关键）

这里有两种做法：

#### MVP 阶段（你现在用）

* 撮合引擎直接调用 service/repo
* 同进程，简单

#### 工业级做法（后期）

* MatchEvent → MQ
* 撮合引擎不碰数据库

#### 当前 MVP 逻辑

```go
// 1. 更新买卖订单状态
UPDATE orders SET status='filled' WHERE id IN (101, 88)

// 2. 插入成交记录
INSERT INTO trades (buy_id, sell_id, price, qty)
```

### Step 13：数据库最终状态

#### orders 表

| id  | status |
| --- | ------ |
| 101 | filled |
| 88  | filled |

#### trades 表

| id | buy_id | sell_id | price | qty |
| -- | ------ | ------- | ----- | --- |
| 1  | 101    | 88      | 49500 | 1   |

## 五、卖单的流程完全一样吗？

**是的，但方向相反**

卖单：

```json
{
  "side": "sell",
  "price": 49500
}
```

* 写 DB
* Submit 给撮合引擎
* 与 Buy 队列撮合

**撮合引擎不关心“是谁先来”**

## 六、用户如何“看到”撮合结果？

### 方式一（现在）

* 用户调用：

  * GET /api/orders
  * GET /api/orders/:id
* 从 DB 看 status 是否变成 filled

### 方式二（后期）

* WebSocket 推送成交事件
* 或 MQ → 推送服务

## 七、这套流程为什么“真实且能扩展”

你现在这个设计：

| 能力    | 是否支持        |
| ----- | ----------- |
| 高并发下单 | ✅           |
| 顺序一致性 | ✅（symbol 级） |
| 撮合性能  | 内存级         |
| 宕机恢复  | DB pending  |
| 分布式扩展 | symbol hash |
| 引入 MQ | 无需推翻        |

## 八、未来容易犯的错误

### 在 Handler 等撮合结果

→ 会把系统拖死

### 让撮合引擎直接操作 HTTP / Gin

→ 架构污染

### 把撮合结果直接 return 给下单接口

→ 并发噩梦

## 九、下一步

- 加部分成交（partial filled）

或

- 把撮合结果改成 Event → Service 解耦

