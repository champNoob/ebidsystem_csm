# 开发笔记

## 1.1 论证阶段

### 在一行代码都没写之前，先做了：

1. 明确业务复杂度（多角色 + 撮合引擎）

2. 设计目录结构

4. 预留扩展空间（DDD / MQ / Redis / Wire）

### 设计理念

- 复杂系统，结构优先于代码

- 绝大多数“写到一半推倒重来”的项目，都是因为：

  - 先写 CRUD

  - 后补架构

- 坑点

  - 目录结构不是越复杂越好

  - 现在这个结构是**“最小复杂度的上限设计”**，是合理的

## 1.2 设计阶段

### 架构设计

#### 明确分层边界

```pgsql
handler → service → repository → database
```

> config 定义“系统怎么被配置”
> database 定义“如何连接基础设施”
> repository 定义“业务如何访问数据”

三者**绝不互相越权**。

并且：

- 禁止反向依赖

- 每一层只干自己的事

#### 设计理念

> 层不是为了“好看”，而是为了“隔离变化”

- HTTP 会变（Gin / Fiber / gRPC）

- DB 会变（MySQL / Redis / ES）

- 业务规则变化最快

所以：

- Service 必须最稳定

- 它不能依赖 HTTP、JSON、Gin

#### 100% 会踩的坑

- repository 返回 HTTP 状态码

- service 使用 gin.Context

- handler 写 SQL

#### 三层的“职责边界”——正反例

##### 1️⃣ config ——“事实来源（Source of Truth）”

> config 应该做什么

* 定义 **配置结构体**
* 负责 **加载 / 解析 / 校验配置**
* 不关心数据库、Redis、业务

> config 不应该做什么

* ❌ 不创建数据库连接
* ❌ 不 import database / redis / sql
* ❌ 不包含任何业务语义

> 正确内容示例

```go
//internal/config/config.go
type MySQLConfig struct {
	DSN string `yaml:"dsn"`
}
```

##### 2️⃣ database ——“基础设施初始化器”

> database 应该做什么

* 根据 **config 提供的参数**
* 初始化 **连接池 / 客户端**
* 提供 **全局可复用实例**

> database 不应该做什么

* ❌ 不定义配置结构
* ❌ 不写 SQL
* ❌ 不知道“用户 / 订单”是什么

> 正确内容示例

```go
//internal/pkg/database/mysql.go
func InitMySQL(cfg config.MySQLConfig) error {
	//只关心如何连，不关心数据
}
```

##### 3️⃣ repository ——“数据访问的业务视角”

> repository 应该做什么

* 定义 **面向业务的接口**
* 实现 CRUD / 查询
* 封装 SQL / Redis 操作细节

> repository 不应该做什么

* ❌ 不加载配置
* ❌ 不初始化连接池
* ❌ 不返回 sql.Rows / redis.Cmd


#### 依赖方向

```
config
   ↓
database
   ↓
repository
   ↓
service
   ↓
api(handler)
```

**任何反向依赖，都是设计错误。**

这一点是后面 **撮合引擎能否独立演进的关键**。

#### 几个设计雷区

- ❌ database 里出现 SQL

- ❌ repository 里读取 config

- ❌ service import database

- ❌ handler 直接操作 sql.DB

- ❌ config import gin / mysql / redis

只要出现一个，后期必重构。

#### 单请求调用链图

![单请求调用链图](https://www.plantuml.com/plantuml/png/RP3FRi8m3CRlVWgB4nnuWHqcnD20QNz6ORTTijOJaKAQ9SwcllrSDuXLu-RwztFrVLaaDf7poG5RTeGLVMLAZFUk_S4vhednBL74POVR5O2fkOruvonvXY2NjhR1UCR9sdgisimK9sXI6STA_wEDyOqhZixNf3t5RrkJIcN-BrKKscGbJlVkfzOpnKzJqqoFUdRzOlhKxNUF5sjx2WuQm-R39CA9KeMh9S3G4-UtfGxUuEPmU3q_4fIjSAsYGcsSmsDffcirpZt4M1FtQQQscK7PYg1f1hhijYkbkXgG1XNSs1GCrqSuxuHBLY4I77UPOWVoEHzVHKhPyP-RKQ0-pIN9g8sYygbeU18X3_kNPwmeXTOdWWNv9f_SBm00)

### config / database 边界纠正

错误在于：

```go
config.MySQLConfig ≠ database.MySQLConfig
```

并最终统一为：

- config：只负责“读取配置”

- database：只接受“连接参数”，不关心来源

#### 正确的边界

模块 | 职责
|----|----|
config | env / yaml → struct
database | struct → *sql.DB
main | 负责“装配”

#### 设计理念

> 配置是“数据”，不是“行为”

#### 坑点

- 把 database 的 config struct 暴露到业务层

- 在 repository 里读 env

### DTO 不得越权（这是你这轮最关键的收获）

#### 正确操作

你意识到并接受了：

```
request.CreateUserRequest ❌ 不能进入 service
```

最终结构定型为：

| 层          | 输入模型                      |
| ---------- | ------------------------- |
| Handler    | request.CreateUserRequest |
| Service    | CreateUserInput           |
| Repository | model.User                |

#### 设计理念

> **DTO 是“协议模型”，不是“业务模型”**

#### 100% 会踩的坑

* “少写一个 struct 多方便”
* “反正字段一样”

这是**中后期项目腐烂的起点**。

### 错误体系放在 Service，而不是 Handler

#### 正确操作

你接受并实现了：

* 业务错误：`service.ErrUserAlreadyExists`
* handler 只负责 → HTTP 翻译

#### 设计理念

> **错误的“语义”属于业务，不属于协议**

#### 坑点

* repository 返回自定义 error
* handler 判断业务规则

### 第一个完整闭环（POST /users）

你现在已经完成了：

```txt
HTTP → Handler → Service → Repo → MySQL
```

而且是：

* 可跑
* 可测
* 可扩展
* 不绑死 Gin

### 建立一条最小可运行链路（Minimum Runnable Skeleton, MRS），确保：

配置能加载 → 基础依赖能初始化（MySQL / Redis）→ Gin 能启动 → 有一个健康接口可访问

#### 1

现在应该做的不是“业务”，而是 4 件事——按优先级排序：

1. 确定程序入口（cmd/server/main.go）
2. 实现配置加载（internal/config）
3. 初始化基础资源（MySQL / Redis）
4. 启动 Gin + 一个 health 接口

撮合引擎、RBAC、订单 CRUD 都暂时不要碰。

#### 2

```go
package main

import (
	"log"

	"ebidsystem_csm/internal/config"
	"ebidsystem_csm/internal/pkg/database"
	"ebidsystem_csm/internal/api/route"
)

func main() {
	//1.加载配置
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("load config failed: %v", err)
	}

	//2.初始化数据库
	if err := database.InitMySQL(cfg.MySQL); err != nil {
		log.Fatalf("init mysql failed: %v", err)
	}

	if err := database.InitRedis(cfg.Redis); err != nil {
		log.Fatalf("init redis failed: %v", err)
	}

	//3.启动 HTTP 服务
	r := route.SetupRouter()
	if err := r.Run(cfg.Server.Addr); err != nil {
		log.Fatalf("server start failed: %v", err)
	}
}

```

### 最小业务纵切面

现在已经验证了：

- 配置能加载

- MySQL / Redis 能 Ping 成功

- Gin 能启动

这说明的是：“连通性 OK”，但下面这些还完全未知：

- repository 的接口设计是否合理？

- service 是否会被迫 import database？

- handler 是否会污染业务逻辑？

- 错误如何向上传递？

- JSON DTO 是否开始膨胀？

这些问题，只有“真实的一条业务链路”才能暴露出来。

因此不推荐继续测 MySQL / Redis，也不推荐只写 repository 或只写 service

#### 一个明确、可执行的目标

实现一个“只读”的 User 查询接口 `GET /users/:id`

它满足：

- 用到 MySQL

- 用到 repository / service / handler

- 不涉及权限、事务、并发、撮合

- 可以作为后续所有接口的模板

### 分层输入模型一览

唯一推荐、长期不会乱的正确结构

```
层	用什么结构
Handler	request.CreateUserRequest
Service	service.CreateUserInput
Repository	model.User
```

它们不是重复，是“裁剪视图”。

### JWT 行为

> “JWT 行为”是系统对 JWT 的使用约定和边界说明。

换句话说：**JWT 行为 = 技术 + 规则 + 取舍**

例如：

- token 是否可多端共存？
- 登录两次会不会踢掉前一个？
- 是否支持主动登出？
- token 里信不信 role？

这些都不是“代码问题”，而是**系统行为定义问题**。

### 订单状态

#### 关于“删除”

> **撤单 ≠ 删除订单**（无论软硬删除）

DELETE 在 REST 中的真实语义是**客户端希望这个资源不再存在**

撤单后订单还存在，仍需要：

- 审计

- 对账

- 回放

- 风控

- 合规

> 不能真的“删除”

## 2. 编写阶段

###