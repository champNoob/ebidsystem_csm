# 后端工程中的「克制原则」反思

> **主题问题**：在前后端分工、内部安全、工程成本、结构简洁等多重约束下，后端是否应当在很多情况下选择「克制」，而不是事必躬亲？

## 一、这是一个“现象”，也是一个“理念”

这不是偶然现象，而是**成熟工程体系中的核心设计理念之一**。

后端的价值，不在于“什么都做”，而在于“只做不可替代的事”。这可以称为：

* 后端克制原则（Backend Restraint Principle）
* 或：职责边界优先原则（Responsibility Boundary First）

它并不是“偷懒”，而是**系统性理性选择**。

## 二、为什么“事必躬亲”的后端反而是危险的？

### 1. 表面看：更安全

很多初学者会自然地产生这种想法：

* 后端最可信 → 多校验一点
* 前端不可靠 → 后端兜底
* 多返回点信息 → 更友好

**短期内，这些想法都是“对的”。**

但它们忽略了一个关键事实：

> **系统风险从来不是由“单点失误”造成的，而是由“复杂度失控”造成的。**

### 2. 实际结果：复杂度指数级膨胀

当后端“什么都管”时，会发生：

* 同一规则在 3 个地方出现（handler / service / middleware）
* 同一错误在 4 个层级被翻译
* 前端和后端开始互相猜测对方行为

在项目中已经出现过：

* 校验错误既来自 `ShouldBind`，也来自 service
* JWT 错误既在 middleware，也在 handler
* 错误 message 该不该暴露反复纠结

这并非代码写得不好，而是**职责边界模糊的必然结果**

## 三、克制原则的本质：明确“谁该负责什么”

### 1. 一个成熟系统的隐含共识

在成熟团队中，通常有如下**非文档化共识**：

| 层级         | 主要职责        | 不该做的事        |
| ---------- | ----------- | ------------ |
| 前端         | 交互、即时反馈、弱校验 | 业务裁决、安全信任    |
| Handler    | 协议转换、错误翻译   | 业务判断         |
| Service    | 业务规则、状态机    | HTTP / UI 语义 |
| Middleware | 横切关注点       | 领域逻辑         |
| DB         | 持久化一致性      | 业务推理         |

**克制 = 严格遵守这一分工。**

## 四、结合项目的具体例子

### 示例一：密码为空时，是否返回“密码不能为空”？

当前正确的克制选择：

```json
{
  "code": "INVALID_INPUT",
  "message": "输入错误"
}
```

* 密码为空是 **UI 层可 100% 防止的问题**
* 后端返回具体提示，会导致：

  * 前端放松校验（反正后端会说）
  * 错误语义泄漏到 API 契约中

> 后端只承诺“合法 / 非法”，不承诺“如何修正输入”。

### 示例二：`ErrInvalidOrderQuery` vs `ErrInvalidOrderStatusQuery`

开发时，曾纠结过是否要合并。最终选择：

* handler 只关心：查询非法 → `ORDER_INVALID_QUERY`
* service 内部精细区分 status 错误

确保了对外接口简洁，对内实现精细。


### 示例三：middleware 是否该返回统一错误结构？

最终让 middleware 使用 `BusinessError`，而不是自己造 JSON。

> 一致性比“层级纯洁”更重要。

这是工程实践中的现实理性，而不是教条主义。

## 五、顶层设计理念总结

可以总结为四条“克制法则”：

### 法则一：后端不替前端做 UX 决策

* 不返回“请填写密码”
* 不返回“用户名格式错误，应包含…”

后端只返回：**是否接受**。

### 法则二：后端不暴露内部结构

* 不返回 SQL 错误
* 不返回字段名、tag 名
* 不返回栈信息

已经通过 `BusinessError` 做到了这一点。

### 法则三：错误码稳定，错误文案可变

* 前端逻辑只依赖 `code`
* `message` 只是展示层

这为未来 **国际化 / A/B 文案 / 产品调整** 留下空间。

### 法则四：能在一层解决的问题，不要跨层解决

* 能在前端校验 → 不在后端精细提示
* 能在 service 决策 → 不在 handler if/else

## 六、如果不克制，将来一定会踩的坑

### 坑 1：错误码爆炸

* 200+ 个错误码
* 前端无法维护
* 文档失控

### 坑 2：前后端互相依赖实现细节

* 前端依赖 message 文案
* 后端不敢改校验顺序

### 坑 3：新人无法理解系统

* 不知道错误从哪里来
* 不敢删任何校验

## 七、一句给未来自己的提醒

> **工程能力的标志，不是“我能处理多少情况”，而是“我知道哪些情况不该我处理”。**
